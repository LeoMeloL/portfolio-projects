# -*- coding: utf-8 -*-
"""cubic_spline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v20cTx0NH4Ix5pK0dX8PvQwLQKJL0Dg6
"""

def natural_cubic_spline(n, x, y, desired_point):
    h = np.diff(x)

    delta = np.zeros((n, n))
    rhs = np.zeros(n)

    # Condições de limite para spline natural
    delta[0, 0] = 1
    delta[-1, -1] = 1
    for i in range(1, n - 1):
        delta[i, i - 1] = h[i - 1]
        delta[i, i] = 2 * (h[i - 1] + h[i])
        delta[i, i + 1] = h[i]

    for i in range(1, n - 1):
        rhs[i] = 3 * ((y[i + 1] - y[i]) / h[i] - (y[i] - y[i - 1]) / h[i - 1])

    # Eliminacão direta
    for i in range(1, n):
        factor = delta[i, i - 1] / delta[i - 1, i - 1]
        delta[i, i] -= factor * delta[i - 1, i]
        rhs[i] -= factor * rhs[i - 1]

    # Substituição para trás
    coefficients = np.zeros(n)
    coefficients[-1] = rhs[-1] / delta[-1, -1]

    for i in range(n - 2, -1, -1):
        coefficients[i] = (rhs[i] - delta[i, i + 1] * coefficients[i + 1]) / delta[i, i]

    # Encontra o segmento que contém o ponto desejado
    segment = np.searchsorted(x, desired_point)

    if segment == 0:
        segment = 1
    elif segment == n:
        segment = n - 1

    hi = x[segment] - x[segment - 1]
    a = coefficients[segment - 1] * (x[segment] - desired_point) ** 3 / (6 * hi)
    b = coefficients[segment] * (desired_point - x[segment - 1]) ** 3 / (6 * hi)
    c = (y[segment - 1] - coefficients[segment - 1] * hi ** 2 / 6) * (x[segment] - desired_point) / hi
    d = (y[segment] - coefficients[segment] * hi ** 2 / 6) * (desired_point - x[segment - 1]) / hi

    spline_value = a + b + c + d

    return spline_value

latitudes = np.array([26.9336, 26.8344, 27.0353, 26.9675])
longitudes = np.array([5.6000, 5.9333, 6.2667, 6.6000])

ans = natural_cubic_spline(len(latitudes), longitudes, latitudes, 6)
print(ans)
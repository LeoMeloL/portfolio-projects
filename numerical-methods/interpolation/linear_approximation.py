# -*- coding: utf-8 -*-
"""linear_approximation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v20cTx0NH4Ix5pK0dX8PvQwLQKJL0Dg6
"""

def linear_regression_exponential(x, y):
    n = len(x)
    if n < 2:
        raise ValueError("Número insuficiente de pontos")

    log_y = np.log(y)
    sum_x = np.sum(x)
    sum_log_y = np.sum(log_y)
    sum_x2 = np.sum(x**2)
    sum_x_log_y = np.sum(x * log_y)

    b = (n * sum_x_log_y - sum_x * sum_log_y) / (n * sum_x2 - sum_x**2)
    log_a = (sum_log_y - b * sum_x) / n
    a = np.exp(log_a)

    return a, b

def linear_regression_power(x, y):
    n = len(x)
    if n < 2:
        raise ValueError("Número insuficiente de pontos")

    log_x = np.log(x)
    log_y = np.log(y)
    sum_log_x = np.sum(log_x)
    sum_log_y = np.sum(log_y)
    sum_log_x2 = np.sum(log_x**2)
    sum_log_x_log_y = np.sum(log_x * log_y)

    b = (n * sum_log_x_log_y - sum_log_x * sum_log_y) / (n * sum_log_x2 - sum_log_x**2)
    log_a = (sum_log_y - b * sum_log_x) / n
    a = np.exp(log_a)

    return a, b

def calculate_r2(y, y_fit):
    ss_res = np.sum((y - y_fit) ** 2)
    ss_tot = np.sum((y - np.mean(y)) ** 2)
    r2 = 1 - (ss_res / ss_tot)
    return r2


a_exp, b_exp = linear_regression_exponential(x, y)
y_exp_fit = a_exp * np.exp(b_exp * x)
r2_exp = calculate_r2(y, y_exp_fit)

x_nonzero = x[1:]
y_nonzero = y[1:]
a_power, b_power = linear_regression_power(x_nonzero, y_nonzero)
y_power_fit = a_power * x_nonzero ** b_power
r2_power = calculate_r2(y[1:], y_power_fit)

# Determinar o melhor ajuste
if r2_exp > r2_power:
    best_fit = 'exponential'
    best_a = a_exp
    best_b = b_exp
    y_fit = y_exp_fit
else:
    best_fit = 'power'
    best_a = a_power
    best_b = b_power
    y_fit = y_power_fit
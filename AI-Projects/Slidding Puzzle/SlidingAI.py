# -*- coding: utf-8 -*-
"""FIApuzzle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WSNjS7LhG31o4q1Gh0T4pYukJgxe0oV7
"""
from collections import deque
import random
import time
import heapq

tempo_inicial = time.time()

class Node:
    def __init__(self, state, parent, action, depth, cost):
        self.state = state
        self.parent = parent
        self.action = action
        self.depth = depth
        self.cost = cost

    def __lt__(self, other):
      return self.cost < other.cost

def astar(initial_state, goal_state, board_size, max_depth):   #Busca com informacao, Heuristica A*
    heap = [(0, Node(initial_state, None, None, 0, 0))]
    explored = set()

    while heap:
        _, node = heapq.heappop(heap)
        explored.add(tuple(map(tuple, node.state)))

        if node.state == goal_state:
            actions = []
            cells = []
            while node.parent is not None:
                actions.append(node.action)
                cells.append(node.state)
                node = node.parent
            actions.reverse()
            cells.reverse()
            return actions, cells

        neighbors = get_neighbors(node.state, board_size)
        for action, state in neighbors:
            if tuple(map(tuple, state)) not in explored:
                cost = node.depth + 1 + manhattan_distance(state, goal_state)
                heapq.heappush(heap, (cost, Node(state, node, action, node.depth + 1, cost)))

def manhattan_distance(state, goal_state): #Heuristica Utilizada no A*
    distance = 0
    size = len(state)
    for i in range(size):
        for j in range(size):
            value = state[i][j]
            if value != 0:
                goal_position = [(p, q) for p in range(size) for q in range(size) if goal_state[p][q] == value][0]
                distance += abs(i - goal_position[0]) + abs(j - goal_position[1])
    return distance

def iddfs(initial_state, goal_state, board_size, max_depth):   #Busca em profundidade Iterativa
  max_depth = 1

  while True:
    resultado =   dfs_limited(initial_state, goal_state, board_size, max_depth)

    if resultado:

      return resultado

    else:

      max_depth += 1

def dfs_limited(initial_state, goal_state, board_size, max_depth): #Busca em profundidade Limitada
    stack = [Node(initial_state, None, None, 0, 0)]
    explored = set()

    while stack:
        node = stack.pop()
        explored.add(tuple(map(tuple, node.state)))

        if node.state == goal_state:
            actions = []
            cells = []
            while node.parent is not None:
                actions.append(node.action)
                cells.append(node.state)
                node = node.parent
            actions.reverse()
            cells.reverse()
            return actions, cells

        if node.depth < max_depth:
          neighbors = get_neighbors(node.state, board_size)
          for action, state in neighbors:
              if tuple(map(tuple, state)) not in explored:
                  stack.append(Node(state, node, action, node.depth + 1, 0))

def dfs(initial_state, goal_state, board_size, max_depth):  #Busca em profundidade

    stack = [Node(initial_state, None, None, 0, 0)]
    explored = set()

    while stack:
        node = stack.pop()
        explored.add(tuple(map(tuple, node.state)))

        if node.state == goal_state:
            actions = []
            cells = []
            while node.parent is not None:
                actions.append(node.action)
                cells.append(node.state)
                node = node.parent
            actions.reverse()
            cells.reverse()
            return actions, cells

        neighbors = get_neighbors(node.state, board_size)
        for action, state in neighbors:
            if tuple(map(tuple, state)) not in explored:
                stack.append(Node(state, node, action, 0, 0))

def bfs(initial_state, goal_state, board_size, max_depth):  #Busca em largura

    frontier = deque([Node(initial_state, None, None, 0, 0)])
    explored = set()

    while frontier:
        node = frontier.popleft()
        explored.add(tuple(map(tuple, node.state)))

        if node.state == goal_state:
            actions = []
            cells = []
            while node.parent is not None:
                actions.append(node.action)
                cells.append(node.state)
                node = node.parent
            actions.reverse()
            cells.reverse()
            return actions, cells

        neighbors = get_neighbors(node.state, board_size)
        for action, state in neighbors:
            if tuple(map(tuple, state)) not in explored:
                frontier.append(Node(state, node, action, 0, 0))

def get_neighbors(state, board_size): #Funcao utilizada para encontrar os Nodes vizinhos na arvore
    size = board_size
    neighbors = []
    actions = ["UP", "DOWN", "LEFT", "RIGHT"]
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]

    zero_position = [(i, j) for i in range(size) for j in range(size) if state[i][j] == 0][0]
    x, y = zero_position

    for action, dx, dy in zip(actions, dx, dy):
        new_x, new_y = x + dx, y + dy
        if 0 <= new_x < size and 0 <= new_y < size:
            new_state = [row.copy() for row in state]
            new_state[x][y], new_state[new_x][new_y] = new_state[new_x][new_y], new_state[x][y]
            neighbors.append((action, new_state))

    return neighbors

def reverse_game(initial_state, num_moves, board_size): #Funcao para fazer o caminho inverso no jogo e montar o tabuleiro inicial
    current_state = initial_state.copy()
    goal_state = [list(range(i * board_size + 1, (i + 1) * board_size + 1)) for i in range(board_size - 1)]
    goal_state.append([0] + list(range(board_size ** 2 - board_size + 1, board_size ** 2)))

    for _ in range(num_moves):
        neighbors = get_neighbors(current_state, board_size)
        valid_neighbors = [(action, state) for action, state in neighbors if state != current_state]

        if valid_neighbors:
            action, new_state = random.choice(valid_neighbors)
            current_state = new_state
        else:
            print("Estado invÃ¡lido, reiniciando jogo.")
            current_state = initial_state.copy()

    return current_state

def print_board(matrix): #Printar o tabuleiro
    for row in matrix:
        print(row)

shuffle = 10  #Numero de embaralhamentos feitos
max_depth = 5  #Profundidade maxima da arvore
board_size = 3  #Tamanho do tabuleiro

goal_state = [list(range(i * board_size + 1, (i + 1) * board_size + 1)) for i in range(board_size - 1)]
goal_state.append(list(range(board_size ** 2 - board_size + 1, board_size ** 2)) + [0])

initial_state = reverse_game(goal_state, shuffle, board_size)
print("Start:")
print_board(initial_state)
print("Goal:")
print_board(goal_state)

actions, cells = bfs(initial_state, goal_state, board_size, max_depth) #Modifique para mudar o algoritmo
print("States:")
for cell in cells:
    print_board(cell)
    print(" ")

print("Moves: ", len(actions))
print("Actions: ", actions)

tempo_final = time.time()
tempo_total = tempo_final - tempo_inicial
print("Execution time: ", float(tempo_total), " seconds")
